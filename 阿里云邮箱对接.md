# 阿里云邮件推送 Python 对接方案

基于搜索结果，我为你整理了两种主流的 Python 对接方式：**官方 SDK 方式** 和 **原生 API 调用方式**。

## 一、准备工作

### 1. 开通服务并获取凭证
- 在阿里云控制台开通 **邮件推送（DirectMail）** 服务
- 创建并验证发信域名和发信地址
- 获取 **AccessKey ID** 和 **AccessKey Secret**（建议创建 RAM 子账号并授予 `AliyunDirectMailFullAccess` 权限）

### 2. 安装 Python SDK

```bash
# 安装核心SDK和邮件推送专用SDK
pip install aliyun-python-sdk-core aliyun-python-sdk-dm

# 或使用阿里云镜像源加速
pip install aliyun-python-sdk-core aliyun-python-sdk-dm -i https://mirrors.aliyun.com/pypi/simple
```

**注意**：Python 版本要求 >= 3.7

## 二、方案一：使用官方 SDK（推荐）

### 1. 单邮件发送接口 `SingleSendMail`

```python
# -*- coding: utf-8 -*-
from aliyunsdkcore.client import AcsClient
from aliyunsdkcore.auth.credentials import AccessKeyCredential
from aliyunsdkdm.request.v20151123 import SingleSendMailRequest

def send_single_email():
    """
    使用阿里云SDK发送单条邮件
    """
    # 配置凭证和区域
    credentials = AccessKeyCredential(
        access_key_id='your-access-key-id',
        access_key_secret='your-access-key-secret'
    )
    
    # 根据你的发信区域选择Endpoint
    # 华东1(杭州): dm.aliyuncs.com
    # 新加坡: dm.ap-southeast-1.aliyuncs.com
    region_id = 'cn-hangzhou'
    client = AcsClient(credential=credentials, region_id=region_id)
    
    # 创建请求
    request = SingleSendMailRequest.SingleSendMailRequest()
    
    # 必填参数
    request.set_AccountName('verified-sender@your-domain.com')  # 已验证的发信地址
    request.set_AddressType(1)  # 0:随机账号 1:发信地址
    request.set_ReplyToAddress('true')  # 是否使用回信地址
    request.set_ToAddress('recipient@example.com')  # 收件人地址，多个用逗号分隔
    request.set_Subject('邮件主题')  # 邮件主题，不超过100字符
    
    # 邮件内容（HtmlBody和TextBody二选一）
    request.set_HtmlBody('<h1>HTML邮件内容</h1><p>支持HTML标签</p>')
    # request.set_TextBody('纯文本邮件内容')
    
    # 可选参数
    request.set_FromAlias('发信人昵称')  # 发信人昵称，小于15字符
    request.set_TagName('邮件标签')  # 控制台创建的标签，用于追踪统计
    request.set_ClickTrace('0')  # 0:关闭数据跟踪 1:开启跟踪
    
    try:
        response = client.do_action_with_exception(request)
        print(f"发送成功: {response}")
        return True
    except Exception as e:
        print(f"发送失败: {e}")
        return False

if __name__ == '__main__':
    send_single_email()
```

### 2. 批量邮件发送接口 `BatchSendMail`

```python
from aliyunsdkdm.request.v20151123 import BatchSendMailRequest

def send_batch_email():
    """
    批量发送邮件，使用收件人列表
    """
    client = AcsClient('your-access-key-id', 'your-access-key-secret', 'cn-hangzhou')
    
    request = BatchSendMailRequest.BatchSendMailRequest()
    
    # 必填参数
    request.set_AccountName('verified-sender@your-domain.com')
    request.set_AddressType(1)
    request.set_TemplateName('your-template-name')  # 控制台创建的模板名称
    request.set_ReceiversName('your-receiver-list')  # 控制台创建的收件人列表名称
    
    # 可选参数
    request.set_TagName('批量标签')
    request.set_ClickTrace('1')
    
    try:
        response = client.do_action_with_exception(request)
        print(f"批量发送成功: {response}")
        return True
    except Exception as e:
        print(f"批量发送失败: {e}")
        return False
```

### 3. 发送带附件的邮件（新版SDK）

```python
# 需要安装新版SDK
# pip install alibabacloud-dm20151123

from alibabacloud_dm20151123.client import Client as DmClient
from alibabacloud_tea_openapi import models as open_api_models
from alibabacloud_dm20151123 import models as dm_models
from alibabacloud_tea_util import models as util_models
from typing import BinaryIO

def send_email_with_attachment():
    """
    使用新版SDK发送带附件的邮件
    """
    # 初始化客户端
    config = open_api_models.Config(
        access_key_id='your-access-key-id',
        access_key_secret='your-access-key-secret'
    )
    config.endpoint = 'dm.aliyuncs.com'  # 根据区域选择
    client = DmClient(config)
    
    # 构建附件
    attachments = []
    with open('/path/to/file.pdf', 'rb') as f:
        attach = dm_models.SingleSendMailAdvanceRequestAttachments(
            file_name='document.pdf',
            file_content=f.read()
        )
        attachments.append(attach)
    
    # 创建请求
    request = dm_models.SingleSendMailAdvanceRequest(
        account_name='verified-sender@your-domain.com',
        address_type='1',
        reply_to_address='true',
        to_address='recipient@example.com',
        subject='带附件的邮件',
        html_body='<h1>请查看附件</h1>',
        attachments=attachments
    )
    
    try:
        response = client.single_send_mail_advance(request, util_models.RuntimeOptions())
        print(f"带附件邮件发送成功: {response}")
        return True
    except Exception as e:
        print(f"发送失败: {e}")
        return False
```

## 三、方案二：原生 API 调用（无SDK依赖）

如果你不想引入SDK，可以直接使用HTTP API，需要自行实现签名逻辑：

```python
import hmac
import uuid
import base64
import datetime
import requests
from hashlib import sha1
from urllib.parse import urlencode, quote

def get_signature(params_str, method, access_key_secret):
    """
    生成阿里云API签名
    """
    to_sign = f"{method}&{quote('/', 'utf-8')}&{params_str}"
    message = to_sign.encode('utf-8')
    key = f"{access_key_secret}&".encode('utf-8')
    
    signature = base64.b64encode(
        hmac.new(key, message, sha1).digest()
    ).decode('utf-8')
    return signature

def send_email_by_api():
    """
    直接调用阿里云邮件推送API
    """
    # 配置信息
    access_key_id = 'your-access-key-id'
    access_key_secret = 'your-access-key-secret'
    method = 'POST'
    host = 'dm.aliyuncs.com'  # 根据区域选择
    
    # 公共参数
    params = {
        'AccessKeyId': access_key_id,
        'Action': 'SingleSendMail',
        'Format': 'JSON',
        'RegionId': 'cn-hangzhou',
        'SignatureMethod': 'HMAC-SHA1',
        'SignatureNonce': str(uuid.uuid4()),
        'SignatureVersion': '1.0',
        'Timestamp': (datetime.datetime.utcnow()).strftime('%Y-%m-%dT%H:%M:%SZ'),
        'Version': '2015-11-23',
        
        # 业务参数
        'AccountName': 'verified-sender@your-domain.com',
        'AddressType': '1',
        'ReplyToAddress': 'true',
        'ToAddress': 'recipient@example.com',
        'Subject': 'API调用测试',
        'HtmlBody': '<h1>通过原生API发送</h1>',
        'FromAlias': '系统通知',
        'TagName': 'api-test'
    }
    
    # 参数排序并编码
    sorted_params = dict(sorted(params.items()))
    encoded_params = urlencode(sorted_params)
    
    # 生成签名
    signature = get_signature(encoded_params, method, access_key_secret)
    params['Signature'] = signature
    
    # 发送请求
    url = f"https://{host}/"
    try:
        response = requests.post(url, data=params)
        result = response.json()
        
        if 'RequestId' in result:
            print(f"发送成功: RequestId={result['RequestId']}")
            return True
        else:
            print(f"发送失败: {result}")
            return False
    except Exception as e:
        print(f"请求异常: {e}")
        return False

if __name__ == '__main__':
    send_email_by_api()
```

## 四、核心API接口说明

### 1. SingleSendMail（单邮件发送）
- **API版本**: `2015-11-23`
- **Endpoint**: 根据区域选择（如 `dm.aliyuncs.com`）
- **关键参数**:
  - `AccountName`: 已验证的发信地址（字符串）
  - `AddressType`: 地址类型（0=随机账号, 1=发信地址）
  - `ToAddress`: 收件人地址（最多100个，逗号分隔）
  - `Subject`: 邮件主题（≤100字符）
  - `HtmlBody`/`TextBody`: 邮件正文（二选一，SDK限制80K）
  - `ReplyToAddress`: 是否启用回信地址（字符串true/false）

### 2. BatchSendMail（批量发送）
- 使用模板和收件人列表，适合营销邮件
- 需预先在控制台创建邮件模板和收件人列表

### 3. 区域Endpoint对照表
| 区域 | RegionId | 公网Endpoint | VPC Endpoint |
|------|----------|--------------|--------------|
| 华东1(杭州) | cn-hangzhou | dm.aliyuncs.com | dm-vpc.cn-hangzhou.aliyuncs.com |
| 新加坡 | ap-southeast-1 | dm.ap-southeast-1.aliyuncs.com | dm-vpc.ap-southeast-1.aliyuncs.com |
| 美国(弗吉尼亚) | us-east-1 | dm.us-east-1.aliyuncs.com | dm-vpc.us-east-1.aliyuncs.com |
| 德国(法兰克福) | eu-central-1 | dm.eu-central-1.aliyuncs.com | dm-vpc.eu-central-1.aliyuncs.com |

## 五、生产环境最佳实践

### 1. 凭证安全管理
```python
import os

# 通过环境变量读取凭证，避免硬编码
access_key_id = os.environ.get('ALIBABA_CLOUD_ACCESS_KEY_ID')
access_key_secret = os.environ.get('ALIBABA_CLOUD_ACCESS_KEY_SECRET')

# 或使用阿里云Credentials工具链（更安全）
# pip install alibabacloud-credentials
from alibabacloud_credentials.client import Client as CredClient
cred_client = CredClient()
```

### 2. 异步发送优化
对于邮件推送系统，建议使用异步队列（如Celery + Redis）：

```python
from celery import Celery

app = Celery('email_tasks', broker='redis://localhost:6379/0')

@app.task
def async_send_email(to_address, subject, html_body):
    """异步发送邮件任务"""
    return send_single_email(to_address, subject, html_body)

# 调用方式
async_send_email.delay('user@example.com', '异步主题', '<h1>异步内容</h1>')
```

### 3. 错误处理与重试机制
```python
from tenacity import retry, stop_after_attempt, wait_exponential

@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=2, max=10))
def send_with_retry(request):
    """带重试机制的发送"""
    return client.do_action_with_exception(request)
```

### 4. 发送限制与注意事项
- **频率限制**: 单个发信地址默认10封/秒，可提工单申请提升
- **收件人数量**: SingleSendMail最多100个，BatchSendMail最多10000个/天
- **内容大小**: HtmlBody/TextBody限制80KB（SDK方式）
- **IP限制**: 如开启IP保护，需将服务器IP添加到白名单
- **附件支持**: 仅新版SDK支持，总大小限制2MB

## 六、总结与建议

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **新版SDK** | 功能完整、支持附件、类型安全 | 依赖较多 | 新项目、需要附件功能 |
| **V1版SDK** | 轻量、简单、文档丰富 | 不支持附件 | 简单邮件发送 |
| **原生API** | 无额外依赖、灵活 | 需自行实现签名、易出错 | 极简环境、特殊需求 |

**推荐方案**: 对于新的邮件推送系统，建议使用**新版SDK**（`alibabacloud-dm20151123`），配合异步队列和凭证安全管理，构建可靠的企业级邮件服务。

需要针对具体场景（如批量营销、触发通知、带附件）的详细实现吗？